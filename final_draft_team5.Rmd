---
title: "Итоговый проект"
author: "Группа 5"
output: 
  html_document:
    code_folding: hide
editor_options: 
  chunk_output_type: inline
---

### Предобработка

Для построения рекомендательной системы нам необходимо было проверить гипотезу о наличии влияния съемочной группы (режиссёр + актёры) на рейтинг фильмов.

Проверять эту гипотезу мы решили следующим образом: объединением актеров и режиссеров в новую колонку "съемочная группа", построив граф, где узлы --- члены съемочной группы, связи --- съемка в одном фильме. После этого были определены сообщества с помощью метода Louvain.

Затем мы рассчитали средний рейтинг фильмов по этим сообществам и провели ANOVA-тест, который показал, что различие в среднем рейтинге фильмов по сообществам является статистически значимым на любом принятом уровне значимости. **В дальнейшем это использовалось при построении content-based рекомендательной системы.**

```{r message = F, warning = FALSE}
# Загрузка датасетов
library(tidyverse)
library(igraph)
library(recommenderlab)
library(readr)
library(tidyr)
load("~/shared/minor2_2023/data/project/metadata_g_5.RData")
```

```{r message = F, warning = FALSE}
# Преобразование датасета: мы создадим новую колонку cast, которая будет состоять из следующих членов съемочной комады: режиссеров и актеров.
split_names = function(x) unlist(strsplit(x, ", "))

# создание колонки cast с актерами и режиссерами 
metadata_filter = metadata %>%
  mutate(directedBy = map(directedBy, split_names),
         starring = map(starring, split_names),
         cast = map2(directedBy, starring, ~c(.x, .y))) %>%
  select(title, cast, avgRating, imdbId) %>%
  unnest_longer(cast) %>% distinct()

# Создание ветвей
edges_list = list()
titles = unique(metadata_filter$title)

for (title in titles) {
  cast_members = metadata_filter$cast[metadata_filter$title == title]
  if (length(cast_members) > 1) {
    combs = combn(cast_members, 2)
    edges_list = append(edges_list, list(combs))
  }
}
edges = unlist(edges_list)

# Создание графа
g = graph(edges = edges, directed = FALSE)

# Добавим атрибут рейтинг
V(g)$rating = sapply(V(g)$name, function(member) {
  mean(metadata_filter$avgRating[metadata_filter$cast == member])
})

# Составим сообщества
set.seed(1234)
communities = cluster_louvain(g)

# Рассчитаем размер сообществ
V(g)$community = communities$membership
community_sizes = data.frame(
  community = communities$membership,
  member = V(g)$name
) %>%
  group_by(community) %>%
  summarise(member_count = n())
```

#### Уберем ненаполненные сообщества (меньше 5 членов)

```{r message = F, warning = FALSE}
large_communities = community_sizes %>% filter(member_count >= 5)
large_community_members = V(g)$name[V(g)$community %in% large_communities$community]

g_filtered = induced_subgraph(g, vids = V(g)$name %in% large_community_members)

set.seed(1234)
communities_filtered = cluster_louvain(g_filtered)

V(g_filtered)$community = communities_filtered$membership

# Рассчитаем количество сообществ
community_sizes_2 <- sizes(communities_filtered)
length(community_sizes_2) # Выявлено 33 сообщества

community_data = data.frame(
  community = as.factor(V(g_filtered)$community),
  rating = sapply(V(g_filtered)$name, function(member) {
    mean(metadata_filter$avgRating[metadata_filter$cast == member])
  })
)
```

Выявлено 33 сообщества.

#### Сделаем ANOVA-тест

В данном случае нулевая гипотеза следующая: "Съёмочная группа (режиссёр + актёры) не влияет на рейтинг фильмов"

```{r message = F, warning = FALSE}
anova_result <- aov(rating ~ community, data = community_data)
anova(anova_result) # p-value < 2.2e-16
```

Итог: p-value меньше любого уровня значимости =\> **нулевая гипотеза отвергается**: группы по съемочной команде статистически отличаются по оценке их фильмов. Получается, связь между съемочной группой и рейтингов фильма есть.

#### Построение столбчатой диаграммы

Показывает различия в средних рейтингах по сообществам

```{r message = F, warning = FALSE}
mean_rating_for_bar = community_data %>% group_by(community) %>% summarize(mean_rating = mean(rating)) %>% ungroup()

ggplot(mean_rating_for_bar, aes(x = factor(community), y = mean_rating)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Средний рейтинг фильмов по сообществам",
       x = "Сообщество",
       y = "Средний рейтинг") +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1))
```

### Коллаборативная фильтрация

Используемый метод --- **IBCF**.

Загружаем необходимые библиотеки и данные

```{r message = F, warning = FALSE}
load("~/shared/minor2_2023/data/project/ratings_g_5.RData")
```

Добавляем собственные оценки фильмов для того, чтобы в дальнейшем использовать их для проверки адекватностии полученного предсказания исходя из личного опыта.

```{r}
ratings = as.data.frame(ratings)
ratings[nrow(ratings) + 1,] = c(4306, 1, 5.0)
ratings[nrow(ratings) + 1,] = c(1367, 1, 4.5)
ratings[nrow(ratings) + 1,] = c(33615, 1, 4.5)
ratings[nrow(ratings) + 1,] = c(50872, 1, 5.0)
ratings[nrow(ratings) + 1,] = c(122916, 1, 2.0)
ratings[nrow(ratings) + 1,] = c(3949, 1, 5.0)

# Внесение данных для ответа на пример №1
ratings[nrow(ratings) + 1,] = c(329, 2, 5.0)
ratings[nrow(ratings) + 1,] = c(3752, 2, 2.0)
ratings[nrow(ratings) + 1,] = c(3499, 2, 5.5)
ratings[nrow(ratings) + 1,] = c(46723, 2, 3.0)
ratings[nrow(ratings) + 1,] = c(2617, 2, 4.0)

# Внесение данных для ответа на пример №2
ratings[nrow(ratings) + 1,] = c(1884, 3, 0.5)
ratings[nrow(ratings) + 1,] = c(7090, 3, 0.5)
ratings[nrow(ratings) + 1,] = c(89745, 3, 0.5)
ratings[nrow(ratings) + 1,] = c(587, 3, 0.5)
ratings[nrow(ratings) + 1,] = c(72407, 3, 0.5)
ratings[nrow(ratings) + 1,] = c(86880, 3, 0.5)

# Внесение данных для ответа на пример №3
ratings[nrow(ratings) + 1,] = c(2329, 4, 0.5)
ratings[nrow(ratings) + 1,] = c(8949, 4, 0.5)
ratings[nrow(ratings) + 1,] = c(63113, 4, 0.5)
ratings[nrow(ratings) + 1,] = c(54272, 4, 0.5)
ratings[nrow(ratings) + 1,] = c(72011, 4, 0.5)

```

Теперь подготовим данные, убрав те, которые являются нерелевантными (если данных мало, основывать вывод на них бессмысленно). Так как если фильм редкий и его мало кто видел, то оценки для него могут быть сильно смещенными. Также если и пользователь оценил малое число фильмов, то ему сложно дать рекомендацию.

Максимальное число фильмов, которое оценил конкретный пользователь -- 59. Минимальное -- 6. В основном же пользователи оценивают до 20 фильмов.

```{r message = F, warning = FALSE}
counts = ratings %>% count(user_id) 
counts %>% top_n(5, n) %>% arrange(-n)

ggplot(counts) + geom_histogram(aes(x = n)) + ggtitle("Распределение количества фильмов, оцененных пользователями")
```

Для более четкого представления посчитаем среднее арифметическое и моду по количеству оценок у пользователей. В среднем пользователи оценивают 12 фильмов, а чаще всего - 6 фильмов (что также является и минимальным количеством оценок среди пользователей). В дальнейшем эта информация нам пригодится для построения модели.

```{r}
mean(counts$n)
u <- unique(counts$n)
tab <- tabulate(match(counts$n, u))
u[tab == max(tab)]
```

Теперь рассмотрим распределение количества оценок по фильмам. Максимальное число оценок у фильма - 330, а минимальное - 14. В общем 14 оценок мы примем как достаточное, чтобы оценки по нему не были смещены, поэтому мы не будем обрезать данные по количеству оценок у фильмов.

```{r}
counts_f = ratings %>% count(item_id) 
counts_f %>% top_n(5, n) %>% arrange(-n)
ggplot(counts_f) + geom_histogram(aes(x = n)) + ggtitle("Распределение количества оценок у фильмов")
```

```{r message = F, warning = FALSE}
rates = pivot_wider(ratings, names_from = item_id, values_from = rating)
```

Попробуем найти самые удачные данные по пользователям для построения модели. Для этого проверим 2 варианта: сильно урежем данные по пользователям (возьмем значение выше среднего арифметического по количеству оценок у пользователей) и немного урежем данные по пользователям (возьмем значение чуть выше минимального количества оценок у пользователей). Рассмотрим исходы следующих вариантов: 1) Нас интересуют пользователи, поставившие не менее 15 оценок. 2) Нас интересуют пользователи, поставившие не менее 8 оценок.

```{r message = F, warning = FALSE}
userNames = rates$user_id
rates = select(rates, -user_id)
rates = as.matrix(rates)
rownames(rates) = userNames
r = as(rates, "realRatingMatrix")
ratings_movies_1 <- r[rowCounts(r) > 15] 
ratings_movies_2 <- r[rowCounts(r) > 8] 
```

Если у пользователей от 15 оценок:

```{r message = F, warning = FALSE}
set.seed(100)
eval_sets1 <- evaluationScheme(data = ratings_movies_1, 
                              method = "split",
                              train = 0.8, # доля обучающей выборки
                              given = 15, # сколько оценок используется для  предсказания
                              goodRating = 4) # если предсказанная оценка < 4, то фильм не рекомендуем
```

Строим вторую рекомендательную модель.

```{r message = F, warning = FALSE}
recc_model1 <-
  Recommender(data = getData(eval_sets1, "train"), method = "IBCF")

recc_predicted1 <-
  predict(
    object = recc_model1,
    newdata = getData(eval_sets1, "known"),
    n = 5,
    type = "ratings"
  )
```

Вычисляем таблицу ошибок, усредненную на всех пользователей.

```{r message = F, warning = FALSE}
eval_accuracy1 <- calcPredictionAccuracy(
      x = recc_predicted1,# predicted values
      data = getData(eval_sets1, "unknown"),
      byUser = F) # not averaging for each user

eval_accuracy1
```

Теперь проверим с пользователями, у которых от 8 оценок:

```{r message = F, warning = FALSE}
set.seed(100)
eval_sets2 <- evaluationScheme(data = ratings_movies_2, 
                              method = "split",
                              train = 0.8, # доля обучающей выборки
                              given = 5, # сколько оценок используется для  предсказания
                              goodRating = 4) # если предсказанная оценка < 4, то фильм не рекомендуем
```

```{r message = F, warning = FALSE}
recc_model2 <-
  Recommender(data = getData(eval_sets2, "train"), method = "IBCF")

recc_predicted2 <-
  predict(
    object = recc_model2,
    newdata = getData(eval_sets2, "known"),
    n = 8,
    type = "ratings"
  )
```

```{r message = F, warning = FALSE}
eval_accuracy2 <- calcPredictionAccuracy(
      x = recc_predicted2,# predicted values
      data = getData(eval_sets2, "unknown"),
      byUser = F) # not averaging for each user

eval_accuracy2
```

Мы можем сравнить полученные модели. Как видно из результатов, наиболее низкие показатели ошибки по всем трем параметрам в сравнении с другими показывает вторая модель, при которой мы оставляли лишь пользователей, оценивших больше 8 фильмов.

```{r message = F, warning = FALSE}
eval_accuracy1
eval_accuracy2
```

#### Функция

Создадим функцию, которая дает рекомендации пользователю. Входные данные: id пользователя и желаемое количество рекомендаций (n). Выходные параметры: название n фильмов, рекомендованных пользователю.

```{r message = F, warning = FALSE}
get_rec <- function(id, n) {
  amount_of_films = ratings %>% filter(user_id == as.integer(id))
  if (nrow(amount_of_films)==0) {
    recommend = "Пожалуйста, оцените несколько фильмов, чтобы мы могли вам что-то порекомендовать."
  } 
  else { 
    recc_predicted <- predict(object = recc_model2, newdata = r, n = n)
          names(recc_predicted@items) = rownames(r)
          
          recc_user_1 <- recc_predicted@items[[id]]
          
          movies_user_1 <- recc_predicted@itemLabels[recc_user_1]
          names_movies_user_1 <- metadata$title[match(movies_user_1, metadata$item_id)]
          recommend = names_movies_user_1
  }
  print(recommend)
}
```

**Оценивание рекомендации:** работоспособность системы была проверена на основе формальных характеристик, что было показано выше. Кроме того, была проведена оценка выдаваемых системой результатов на адекватность: мы ознакомились с жанрами и кратким сюжетом выданных фильмов и сравнили их с теми, которые были оценены пользователем ранее, затем сделали выводы, насколько их характеристики коррелируются между собой.

Проверим на рандомном пользователе с id "4045". Он оценивал фильмы, относящиеся к таким жанрам, как драма, фантастика, боевик (например, Форест Гамп, Я - легенда, «V» значит Вендетта, Кловерфилд, Эрин Брокович и пр.). Причем более высокие оценки (4.0-4.5) он ставит драматическим фильмам. Рекомендация ему выдала фильмы, которые относятся к жанрам: фантастика, боевик, триллер. Как кажется, эта рекомендация вполне адекватна.

```{r message = F, warning = FALSE}
get_rec("4045", 3)
```

Посмотрим результаты для себя -- id "1". Были оценены разнообразные фильмы, но по преимуществу это были комедийные и фэнтезийные фильмы (мультфильмы), например, Шрек, Рататуй, Мадагаскар. Кроме того, был добавлен Тор и Реквием по мечте -- чтобы добавить больше фэнтези и драмы. В итоге рекомендация выдала больше фильмов, относящихся к комедии и фэнтези. В то же время Вавилон (фильм, 2006) - это драма, и он больше соотносится с Реквиемом по мечте. Думается, что это также подтверждает, что полученная рекомендация адекватна.

```{r message = F, warning = FALSE}
get_rec("1", 5)
```

### Content-based рекомендация

Загрузка необходимых библиотек и данных:

```{r message = F, warning = FALSE}
data = metadata %>% dplyr::select(title, item_id, directedBy, starring, avgRating)

data[["avgRating"]] = data[["avgRating"]] / max(data$avgRating) # нормализуем рейтинг
data = subset(data, select = - c(avgRating))

library(qdapTools)
data = cbind(data, mtabulate(strsplit(data$directedBy, ", "))) # one hot режиссеров
data = cbind(data, mtabulate(strsplit(data$starring, ", "))) # one hot актеров
data = subset(data, select = - c(directedBy, starring))
```

Нормализуем вектора написанной функцией normalize_rows, затем сторим матрицу схожести и датасет из 5 фильмов с самым высоким рейтингом.

```{r message = F, warning = FALSE}
normalize_rows = function(df) {
  df_norm = apply(df, 1, function(row) {
    row / sqrt(sum(row^2))
  })
  df_norm = data.frame(t(df_norm))
  colnames(df_norm) = colnames(df)
  return(df_norm)
}

rownames = data$item_id
data = subset(data, select = - c(item_id, title))
rownames(data) = rownames
data = normalize_rows(data)
sim = lsa::cosine(t(as.matrix(data)))
diag(sim) = 0

best = head(metadata[order(-metadata$avgRating),], n = 5) %>% select(title, avgRating)
```

#### Функция

Функция принимает на вход id пользователя, для каждого фильма, которому он поставил оценку 5 (если таких нет, то 4) функция находит 5 фильмов с самым большим косинусным сходством (с похожим актерским составом, режиссерами), объединяет рекомендации и возвращает топ-5 фильмов по рейтингу. Если пользователь не ставил оценки 4 или 5, то функция возвращает топ-5 фильмов с самым высоким рейтингом в датасете.

```{r message = F, warning = FALSE}
getFilms = function(userId){
  if (nrow(ratings %>% filter(user_id == userId & rating == 5)) != 0) {
    user = ratings %>% filter(user_id == userId & rating == 5)
  } else if (nrow(ratings %>% filter(user_id == userId & rating == 4)) != 0) {
    user = ratings %>% filter(user_id == userId & rating == 4)
  } else {return(best)}
  find_and_combine = function(item_id) {
    mostSimilar = head(sort(sim[,as.character(item_id)], decreasing = T), n = 5)
    mostSimilar = data.frame(similar = mostSimilar)
    mostSimilar$item_id = as.numeric(rownames(mostSimilar))
    result = mostSimilar %>% left_join(metadata) %>% select(title, similar, directedBy, starring, avgRating) %>% arrange(-similar)
    return(result)
  }
  combined_results = lapply(user$item_id, find_and_combine)
  final_result = do.call(rbind, combined_results)
  return(head(final_result[order(-final_result$avgRating),], n = 5))
}
```

```{r message = F, warning = FALSE}
getFilms(118278) #118278 473101
```

**Оценивание рекомендации:** данная рекомендательная система оценивалась аналогично предыдущей, то есть на основе формальных характеристик, а также была проведена оценка выдаваемых системой результатов на адекватность.

### Примеры

##### Примеры collaborative filtering

В случае, если у пользователя не будет оценено ни одного фильма, ему выводится сообщение о том, что ему необходимо оценить несколько фильмов, чтобы у нас была возможность дать ему рекомендацию.

**Пример 1:** "Хотелось бы получить рекомендацию для нового пользователя, если он оценит следующие фильмы так: Star Trek: Generations (1994) - 5 Me, Myself & Irene (2000) - 2 Misery (1990) - 5 Babel (2006) - 3 Mummy, The (1999) - 4"

*Ответ:* Для ответа на этот вопрос мы предварительно добавили в датасет нового пользователя и присвоили ему id[2] в соответствии с данными характеристиками.

```{r message = F, warning = FALSE}
get_rec("2", 2)
```

Как видим, в рекомендациях отражаются и приключенский жанр, и комедия, связанный с данными пользователем оценками, также имеется драматический фильм, соответсвующий высоким оценкам фильма такого же жанра

**Пример 2:** "Любопытно, что бы порекомендовалось пользователю, который поставил всем своим фильмам минимальные оценки?"

*Ответ:* Для ответа на этот вопрос мы предварительно добавили в датасет нового пользователя и присвоили ему id[3] в соответствии с данными характеристиками. Минимальная оценка = 0.5

Так как в вопросе не было указано, к какому жанру должны относиться фильмы, выбраны были рандомные, но всем присвоена низкая оценка.

```{r message = F, warning = FALSE}
get_rec("3", 5)
```

Преобладают жанры: драма, боевик. Если обратиться к фильмам, которые были добавлены для этого примера и которым были присвоены низкие оценки, станет ясно, что они действительно получились рандомными \-- все они мало схожи по жанрам (Приведение, Сумерки, Пираты Карибского моря, Мстители, Герой (2002), Страх и ненависть в Лас-Вегасе). Полученные рекомендации при этом не выдают пользователю фильмы, похожие на непонравившиеся ему ранее \-- то есть в выходных данных мы не находим фильмов с такими жанрами, как романтика, фэнтези, исторический нарратив, психоделика.

**Пример 3:** "Если были предложены фильмы основной жанр которых к примеру драма, и я поставил им всем низкие баллы, то какие фильмы мне предложит система?"

Для ответа на этот вопрос мы предварительно добавили в датасет нового пользователя и присвоили ему id[4]. Все фильмы с тэгом драма мы внесли ему и дали им минимальную оценку = 0.5

```{r message = F, warning = FALSE}
get_rec("4", 5)
```

Полученная рекомендация практически не выдает фильмы, относящиеся к жанру драма, за исключением фильма "Реквием по мечте". Остальные относятся к жанрам: научная-фантастика, комедия, боевик, приключения.

##### Примеры content-based

**Пример 1:**

В рекомендательной системе content-based мы обговаривали такую ситуацию, когда пользователь ставил довольно низкие оценки на все фильмы (максимальная оценка меньше 4). Также по поводу этого было много вопросов в peer review. Мы решили, что в такой ситуации будем просто рекомендовать топ-5 фильмов, проверим это на примере пользователей с id 72774 и 68109. Вот их оценки:

```{r message = F, warning = FALSE}
ratings %>% filter(user_id == '72774') 
ratings %>% filter(user_id == '68109') 
```

Как мы видим, они действительно не ставили оценок 4 и выше. Смотрим, что им порекомендует система:

```{r message = F, warning = FALSE}
getFilms(72774)
getFilms(68109)
```

Как мы видим, система работает правильно, и рекомендует верхушку из топа фильмов по рейтингу.

**Пример 2:** Также довольно много вопросов из peer review звучали примерно так: Мне нравятся фильмы с таким-то актером, будет ли система выводить другие фильмы с ним или что-то похожее? Проверим это на примере с Робертом де Ниро (так как он был в одном из вопросов). Для примера будем использовать пользователя с user id 527104, который поставил фильму Goodfellas (item_id = 1213) с де Ниро в главной роли оценку 5:

```{r message = F, warning = FALSE}
ratings %>% filter(user_id == '527104') 
getFilms(527104)
```

Как мы видим, наиболее похожий фильм, который выдает система - это Bronx Tale c де Ниро в главной роли. К тому же, этот фильм еще и в одном жанре со "Славными парнями". Кажется, что система в данном случае сработала очень хорошо.

**Пример 3:** В данном случае мне кажется что было бы релевантно проверить связки актеров и режиссеров, которые много работали вместе и посмотреть будет ли система выдавать именно их например Мартин Скорсезе и Роберт Де Ниро (примечательно, что в датасете нет ни одного их общего фильма))))) Или что фильм Скорцезе с дикаприо должен реоменоваться пользователи больше, чем фильм скорцезе без дикаприо или фильм дикапрео без скорцезе.

Немного странный вопрос. Если пользователю не нравились фильмы Скорсезе и ДиКаприо, то, очевидно, что система не будет их рекомендовать. Поэтому проверим, будет ли система выдавать фильмы с этим режиссером и актером, если пользователь высоко оценивал их другие работы. Проверим это на пользователе с id 664013, который поставил 5 баллов фильму Волк с Уолл-стрит:

```{r message = F, warning = FALSE}
getFilms(664013)
```

Как мы видим, один из рекомендованных фильмов - это "Отступники" Мартина Скорсезе с ДиКаприо в ролях.

**Пример 4:** Что будет, если я укажу, что хочу узнать рекомендации фильмов по пользователю с id 561711.

Не менее странный вопрос, но окей. Посмотрим, что выдаст система:

```{r message = F, warning = FALSE}
getFilms(561711)
```

Видимо, пользователя с таким айди нет в системе, и она рекомендует просто топ-5 фильмов.

**Пример 5:** Я, например, очень хочу посмотреть фильм с Генри Кавиллом, что я получу на выход, и какой будет рейтинг у рекомендованных фильмов?

Предположим, ты высоко оценивал фильмы с Генри Кавиллом. Проверим, выдаст ли система другие фильмы с ним. Проверим это на примере пользователя c id 847268, который поставил 5 фильму "Агенты А.Н.К.Л":

```{r message = F, warning = FALSE}
getFilms(847268)
```

Система не вывела другие фильмы с этим актером, так как в датасете был только один фильм с Генри Кавиллом. Зато среди рекомендованных фильмов есть Шерлок Холмс, который немного схож по жанру с понравившимся фильмом.

**Дополнительный сценарий:** Найдите 2х пользователей, которым нравятся фильмы Мартина Скорсезе и фильмы, снятые до 2000 года. Порекомендуйте им что-то с помощью контент-бейзд системы. Насколько схожи результаты? Почему?

Мы будем проверять этот сценарий на примере двух пользователей: id_671196 и id_27355. Первый пользователь поставил оценку 5 следующим фильмам Скорсезе: Gangs of New York (2002) и Goodfellas (1990). Из фильмов до 2000 года ему понравились: Office Space (1999), Candyman (1992). Второму пользователю также понравился фильм Goodfellas (1990) Мартина Скорсезе, а из фильмов, снятых до 2000 года он оценил на 5: Iron Giant, The (1999), Teenage Mutant Ninja Turtles (1990), Lethal Weapon 3 (1992).

Посмотрим, какие рекомендации система выдаст первому пользователю:

```{r}
getFilms(671196)
```

А теперь смотрим на рекомендацию второму пользователю:

```{r}
getFilms(27355)
```

Единственное сходство, которое можно заметить в рекомендованных фильмах - это то, что большинство из них для обоих пользователей были сняты до 2000г. В целом фильмы рекомендуются довольно разные, но это может быть связано с тем, что оба пользователя были щедрыми на оценки: Первый пользователь поставил 5 всем фильмам, которые оценивал, а второй поставил одну оценку 2 и все остальные 5. Из-за этого системе пришлось выбирать из слишком большого списка.

### Выводы

Результаты сетевого анализа (доказанное с помощью статистического теста наличие связи между съёмочной группой и рейтингом фильма) легли в основу построения content-based рекомендательной системы, которая была нацелена на рекомендацию фильмов с «любимыми» режиссёрами и актёрами пользователю.

Рекомендательная система, построенная с помощью метода коллаборативной фильтрации, рекомендовала пользователям n-количество фильмов в зависимости от их схожести.

Обе рекомендательные системы работают корректно. Это было проверено при помощи формальной оценки, а также теста на адекватность.
